library("eRm")
library("dplyr")
library("psychonetrics")
library("qgraph")
library("mirt")
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
library("eRm")
library("dplyr")
library("psychonetrics")
library("qgraph")
library("mirt")
#simulating Rasch homogenous data
# 1000 persons, 30 items, parameter drawn from N(0,1)
data <- sim.rasch(1000, 10)
data <- as.data.frame(data)
colnames(data) <- paste0("i", 1:10)
vars <- names(data)
# Form saturated model:
model1 <- Ising(data, vars = vars)
# Run model:
model1 <- model1 %>% runmodel
# Prune-stepup to find a sparse model:
model1b <- model1 %>% prune(alpha = 0.05) %>% stepup(alpha = 0.05)
# Compare all models:
comparison <- compare(
`1. all parameters free (dense)`  = model1,
`2. all parameters free (sparse)` = model1b)
# Print results:
print(comparison)
# Make labels:
labels <- paste0("item", 1:10)
# Extract network structure and thresholds:
network <- getmatrix(model1b, "omega")
thresholds <- getmatrix(model1b, "tau")
# Scale thresholds for colors:
scaledthresh <- as.vector(thresholds / (2*max(abs(thresholds))))
# Make colors:
cols <- ifelse(scaledthresh < 0, "red", "darkblue")
cols[scaledthresh>0] <- qgraph:::Fade(cols[scaledthresh>0],alpha = scaledthresh[scaledthresh>0], "white")
cols[scaledthresh<0] <- qgraph:::Fade(cols[scaledthresh<0],alpha = abs(scaledthresh)[scaledthresh<0], "white")
# Plot network:
qgraph(network, layout = "spring", labels = labels,
shape = "rectangle", vsize = 15, vsize2 = 8,
theme = "colorblind", color = cols,
cut = 0.5, repulsion = 0.9)
# Testlet response model
library("mirt")
# Simulate data
set.seed(2021)
a <- matrix(0, 12, 4)
a[,1] <- rlnorm(12, .2, .3)
ind <- 1
for(i in 1:3){
a[ind:(ind+3),i+1] <- a[ind:(ind+3),1]
ind <- ind+4
}
print(a)
d <- rnorm(12, 0, .5)
sigma <- diag(c(1, .5, 1, .5))
dataset <- simdata(a, d, 2000, itemtype=rep('2PL', 12), sigma=sigma)
dataset <- as.data.frame(dataset)
vars <- names(dataset)
# Form saturated model:
model1 <- Ising(dataset, vars = vars)
# Run model:
model1 <- model1 %>% runmodel
# Prune-stepup to find a sparse model:
model1b <- model1 %>% prune(alpha = 0.05) %>% stepup(alpha = 0.05)
# Compare all models:
comparison <- compare(
`1. all parameters free (dense)`  = model1,
`2. all parameters free (sparse)` = model1b)
# Print results:
print(comparison)
# Make labels:
labels <- paste0("Item_", 1:12)
# Extract network structure and thresholds:
network <- getmatrix(model1b, "omega")
thresholds <- getmatrix(model1b, "tau")
# Scale thresholds for colors:
scaledthresh <- as.vector(thresholds / (2*max(abs(thresholds))))
# Make colors:
cols <- ifelse(scaledthresh < 0, "red", "darkblue")
cols[scaledthresh>0] <- qgraph:::Fade(cols[scaledthresh>0],alpha = scaledthresh[scaledthresh>0], "white")
cols[scaledthresh<0] <- qgraph:::Fade(cols[scaledthresh<0],alpha = abs(scaledthresh)[scaledthresh<0], "white")
# Plot network:
qgraph(network, layout = "spring", labels = labels,
shape = "rectangle", vsize = 15, vsize2 = 8,
theme = "colorblind", color = cols,
cut = 0.5, repulsion = 0.9)
install.packages("EGAnet")
library(dplyr)
# Students from Alberta, Canada
load("scr_canada.Rdata")
# First 6 rows of the data
head(scr_canada)
# Variable names
names(scr_canada)
# Save the data as a data.frame
scr_canada <- as.data.frame(scr_canada)
# Select only the SCR items
scr <- select(scr_canada, starts_with("ASBR08"))
# Remove students with no valid responses and recode 9 as missing
scr_nomissing <- scr %>%
filter_all(all_vars(!is.na(.))) %>%
mutate_all(~na_if(., 9)) %>%
as.data.frame()
head(scr_nomissing)
table(scr_canada$IDGRADE)
class(scr_canada)
head(scr_canada)
table(scr_canada$IDGRADE)
write.csv(scr_canada, "scr_canada.csv", quote = FALSE, row.names = FALSE)
head(scr_canada)
# Students from Alberta, Canada
load("scr_canada.Rdata")
# First 6 rows of the data
head(scr_canada)
# Variable names
names(scr_canada)
# Save the data as a data.frame
scr_canada <- as.data.frame(scr_canada)
class(scr_canada)
write.csv(scr_canada, "scr_canada.csv", quote = FALSE, row.names = FALSE)
rlang::last_trace()
library(haven)
write.csv(scr_canada, "scr_canada.csv", quote = FALSE, row.names = FALSE)
# Students from Alberta, Canada
scr_canada <- read.csv("scr_canada.csv", header = TRUE)
# First 6 rows of the data
head(scr_canada)
# Variable names
names(scr_canada)
# Select only the SCR items
scr <- select(scr_canada, starts_with("ASBR08"))
# Remove students with no valid responses and recode 9 as missing
scr_nomissing <- scr %>%
filter_all(all_vars(!is.na(.))) %>%
mutate_all(~na_if(., 9)) %>%
as.data.frame()
head(scr)
head(scr_nomissing)
head(scr)
scr %<>%
filter_all(all_vars(!is.na(.))) %>%
mutate_all(~na_if(., 9)) %>%
as.data.frame()
head(scr)
library("ggcorrplot")
# Save the correlation matrix
cormat <- psych::polychoric(x = scr)$rho
# Correlation matrix plot
ggcorrplot::ggcorrplot(corr = cormat, # correlation matrix
type = "lower", # print only the lower part of the correlation matrix
hc.order = TRUE, # hierarchical clustering
show.diag = TRUE, # show the diagonal values of 1
lab = TRUE, # add correlation values as labels
lab_size = 3) # Size of the labels
library("bootnet")
network1 <- bootnet::estimateNetwork(
data = scr,
corMethod = "cor_auto", # for polychoric and polyserial correlations
default = "EBICglasso", # for estimating GGM with gLASSO and EBIC
tuning = 0.5 # EBIC tuning parameter; set to zero for BIC model selection
)
print(network1)
plot(network1, layout = "spring")
plot(network1)
# See the weighted partial correlations as a heatmap
cor.net <- network1$graph
# Plot the correlation matrix as an interactive heatmap
plotly::plot_ly(x = colnames(cor.net),
y = colnames(cor.net),
z = cor.net,
type = "heatmap")
ggcorrplot::ggcorrplot(corr = cor.net, # correlation matrix
type = "lower", # print only the lower part of the matrix
hc.order = TRUE, # hierarchical clustering
show.diag = TRUE, # show the diagonal values of 1
lab = TRUE, # add correlation values as labels
lab_size = 3) # Size of the labels
ggcorrplot::ggcorrplot(corr = cor.net, # correlation matrix
type = "lower", # print only the lower part of the matrix
hc.order = FALSE, # hierarchical clustering
show.diag = TRUE, # show the diagonal values of 1
lab = TRUE, # add correlation values as labels
lab_size = 3) # Size of the labels
library("plotly")
library("psychonetrics")
obsvars <- colnames(scr)
network2 <- psychonetrics::ggm(scr, vars = obsvars) %>%
psychonetrics::runmodel()
network2 %>% psychonetrics::parameters()
network2 %>% psychonetrics::fit()
network3 <- psychonetrics::ggm(scr, vars = obsvars) %>%
psychonetrics::runmodel() %>%
psychonetrics::prune(adjust = "fdr", alpha = 0.05)
# View the model parameters
network3 %>% psychonetrics::parameters()
# Look at the model fit
network_sapa_3 %>% psychonetrics::fit()
network3 <- psychonetrics::ggm(scr, vars = obsvars) %>%
psychonetrics::runmodel() %>%
psychonetrics::prune(adjust = "fdr", alpha = 0.05)
# View the model parameters
network3 %>% psychonetrics::parameters()
# Look at the model fit
network3 %>% psychonetrics::fit()
comparison <- psychonetrics::compare(
`1. Original model`  = network2,
`2. Sparse Model: Only Pruning` = network3)
print(comparison)
plot(network2)
?psychonetrics::plot.esa
?psychonetrics::ggm
library("EGAnet")
bootEGA1 <- EGAnet::bootEGA(
data = scr,
cor = "cor_auto",
uni.method = "louvain",
iter = 500, # Number of replica samples to generate
# resampling" for n random subsamples of the original data
# parametric" for n synthetic samples from multivariate normal dist.
type = "parametric",
# EGA Uses standard exploratory graph analysis
# EGA.fit Uses total entropy fit index (tefi) to determine best fit of EGA
# hierEGA Uses hierarchical exploratory graph analysis
EGA.type = "EGA",
model = "glasso",
algorithm = "walktrap", # or "louvain" (better for unidimensional structures)
# use "highest_modularity", "most_common", or "lowest_tefi"
consensus.method = "highest_modularity",
typicalStructure = TRUE, # typical network of partial correlations
plot.typicalStructure = TRUE, # returns a plot of the typical network
ncores = 8 # Number of cores to use in computing results
)
bootEGA1 <- EGAnet::bootEGA(
data = scr,
cor = "cor_auto",
uni.method = "louvain",
iter = 500, # Number of replica samples to generate
# resampling" for n random subsamples of the original data
# parametric" for n synthetic samples from multivariate normal dist.
type = "parametric",
# EGA Uses standard exploratory graph analysis
# EGA.fit Uses total entropy fit index (tefi) to determine best fit of EGA
# hierEGA Uses hierarchical exploratory graph analysis
EGA.type = "EGA",
model = "glasso",
algorithm = "walktrap", # or "louvain" (better for unidimensional structures)
# use "highest_modularity", "most_common", or "lowest_tefi"
consensus.method = "highest_modularity",
typicalStructure = TRUE, # typical network of partial correlations
plot.typicalStructure = TRUE, # returns a plot of the typical network
ncores = 8, # Number of cores to use in computing results
seed = 2024 # set the seed for replicability
)
bootEGA1$EGA
bootEGA1$typicalGraph$typical.dim.variables
dim_scr <- EGAnet::dimensionStability(bootEGA1)
dim_scr$dimension.stability
dim_scr$item.stability
dim_scr$item.stability$plot # to see only the plot
riEGA <- EGAnet::bootEGA(
scr,
uni.method = "LE",
iter = 500,
type = "parametric",
cor = "cor_auto",
model = "glasso",
EGA.type = "riEGA", # select random-intercept EGA here
consensus.method	= "highest_modularity",
consensus.iter = 100,
algorithm="walktrap"
)
riEGA <- EGAnet::bootEGA(
scr,
uni.method = "LE",
iter = 500,
type = "parametric",
cor = "cor_auto",
model = "glasso",
EGA.type = "riEGA", # select random-intercept EGA here
consensus.method	= "highest_modularity",
consensus.iter = 100,
algorithm="walktrap",
seed = 2024
)
print(riEGA)
riEGA$RI
riEGa
riEGA
table(scr_canada$IDGRADE)
table(scr_canada$ITSEX)
head(scr_canada)
?corFiml
scr_canada$gender <- as.factor(ifelse(scr_canada$ITSEX==1,"girl",
ifelse(scr_canada$ITSEX==2, "boy", NA)))
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), gender) %>%
dplyr::filter_all(all_vars(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
as.data.frame()
?dplyr::filter_all
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), gender) %>%
dplyr::filter_all(vars(starts_with("ASBR08")), all_vars(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
as.data.frame()
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), gender) %>%
dplyr::filter_all(vars(starts_with("ASBR08")), ~(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
as.data.frame()
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), gender) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
as.data.frame()
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), ITSEX) %>%
dplyr::filter_all(all_vars(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
dplyr::mutate(gender = as.factor(ifelse(ITSEX==1,"girl",
ifelse(scr_canada$ITSEX==2, "boy", NA))))
as.data.frame()
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), ITSEX) %>%
dplyr::filter_all(all_vars(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
dplyr::mutate(gender = as.factor(ifelse(ITSEX==1,"girl",
ifelse(scr_canada$ITSEX==2, "boy", NA)))) %>%
as.data.frame()
head(scr2)
table(scr2$gender)
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), ITSEX) %>%
dplyr::filter_all(all_vars(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
dplyr::mutate(gender = as.factor(ifelse(ITSEX==1,"girl",
ifelse(scr_canada$ITSEX==2, "boy", NA)))) %>%
dplyr::select(-ITSEX) %>%
as.data.frame()
head(scr2)
nmt_scr <- networktree(nodevars=scr2,
splitvars=scr2[,c("gender")],
transform="pcor",
na.action=na.omit)
library("networktree")
dim(scr)
dim(scr2)
nmt_scr <- networktree::networktree(nodevars=scr,
splitvars=scr2[,c("gender")],
transform="pcor",
na.action=na.omit)
plot_scr <- plot(nmt_scr, transform="pcor",
maximum=0.2,edge.width=5,vsize=10,
theme="colorblind", tnex = 3,
partyargs=list(ep_args = list(justmin = 15),
gp = grid::gpar(cex = .6)))
plot(nmt_scr)
hist(scr_canada$ASRREA01)
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), ITSEX, ASRREA01) %>%
dplyr::filter_all(all_vars(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
dplyr::mutate(gender = as.factor(ifelse(ITSEX==1,"girl",
ifelse(scr_canada$ITSEX==2, "boy", NA))),
reading = ifelse(ASRREA01 < 500, "below average", "above average")) %>%
dplyr::select(-ITSEX, ASRREA01) %>%
as.data.frame()
nmt_scr <- networktree::networktree(nodevars=scr,
splitvars=scr2[,c("gender", "reading")],
transform="pcor",
na.action=na.omit)
scr2 <- dplyr::select(scr_canada, starts_with("ASBR08"), ITSEX, ASRREA01) %>%
dplyr::filter_all(all_vars(!is.na(.))) %>%
dplyr::mutate_all(~na_if(., 9)) %>%
dplyr::mutate(gender = as.factor(ifelse(ITSEX==1,"girl",
ifelse(scr_canada$ITSEX==2, "boy", NA))),
reading = as.factor(ifelse(ASRREA01 < 500, "below average", "above average"))) %>%
dplyr::select(-ITSEX, ASRREA01) %>%
as.data.frame()
nmt_scr <- networktree::networktree(nodevars=scr,
splitvars=scr2[,c("gender", "reading")],
transform="pcor",
na.action=na.omit)
plot_scr <- plot(nmt_scr, transform="pcor",
maximum=0.2,edge.width=5,vsize=10,
theme="colorblind", tnex = 3,
partyargs=list(ep_args = list(justmin = 15),
gp = grid::gpar(cex = .6)))
plot_scr <- plot(nmt_scr)
plot_scr <- plot(nmt_scr, transform="pcor", maximum=0.2, edge.width=5, vsize=10, theme="colorblind", tnex = 3, partyargs=list(ep_args = list(justmin = 15), gp = grid::gpar(cex = .6)))
plot(nmt_scr, transform="pcor", maximum=0.2, edge.width=5, vsize=12, theme="colorblind", tnex = 3, partyargs=list(ep_args = list(justmin = 15), gp = grid::gpar(cex = .6)))
plot(nmt_scr, transform="pcor", maximum=0.2, edge.width=5, vsize=12, theme="colorblind", tnex = 5, partyargs=list(ep_args = list(justmin = 15), gp = grid::gpar(cex = .6)))
plot(nmt_scr, transform="pcor", maximum=0.2, edge.width=5, vsize=12, theme="colorblind", tnex = 8, partyargs=list(ep_args = list(justmin = 15), gp = grid::gpar(cex = .6)))
plot(nmt_scr, transform="pcor", maximum=0.2, edge.width=5, vsize=12, theme="colorblind", tnex = 8, partyargs=list(ep_args = list(justmin = 10), gp = grid::gpar(cex = .6)))
